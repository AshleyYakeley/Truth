#!/usr/bin/pinafore

let

# Create a window with some standard menus
# arguments are title reference, more menus, content UI
stdWindow: WholeRef +Text -> [MenuItem] -> UI -> Action Window;
stdWindow title moremenus content = fixAction $ \window -> let
    menus: [MenuItem];
    menus =
        [
            menuSubmenu "File"
            [
                menuAction "Close" (Just "Ctrl+W") {closeWindow window},
                menuSeparator,
                menuAction "Exit" (Just "Ctrl+Q") {exitUI}
            ],
            menuSubmenu "Edit"
            [
                menuAction "Undo" (Just "Ctrl+Z") {queueUndo},
                menuAction "Redo" (Just "Ctrl+Y") {queueRedo}
            ]
        ] ++ moremenus;
    in openWindow title {menus} $ uiScrolled content;

selectionWindow:
    Text -> # window title
    SetRef item -> # the set of items
    [(item -> Action ()) -> MenuItem] -> # Menu items for creating new items
    (item -> Action Any) -> # what to do when an item is activated
    (WholeRef item -> UI) ->
    Action Window;
selectionWindow wtitle iset createMenuItems iopen iui = do
    selection <- newMemWhole;
    let
        viewItem: Action ();
        viewItem = do
            item <- get selection;
            iopen item;
            return ();
            end;

        deleteItem: Action ();
        deleteItem = do
            item <- get selection;
            iset -= item;
            end;

        moremenus: [MenuItem];
        moremenus =
            [
                menuSubmenu "Selection" $ mapList (\mi -> mi $ \i -> selection := i) createMenuItems ++
                [
                    menuAction "View" Nothing {viewItem},
                    menuAction "Delete" Nothing {deleteItem}
                ]
            ];
        in stdWindow {wtitle} moremenus (iui selection);
    end;


### EventTime

closedtype EventTime
    = EventTimeDate Date !"Date" # all-day event
    | EventTimeTime LocalTime !"Time"; # event at a time

showEventTime: EventTime -> Text;
showEventTime et = case et of
    EventTimeDate d -> toText d;
    EventTimeTime t -> toText t;
    end;

eventTimeDate: EventTime -> Date;
eventTimeDate et = case et of
    EventTimeDate d -> d;
    EventTimeTime (LocalTime d _) -> d
    end;

setEventTimeDate: Date -> Maybe EventTime -> Maybe EventTime;
setEventTimeDate d et = Just $ case et of
    Just (EventTimeTime (LocalTime _ t)) -> EventTimeTime (LocalTime d t);
    _ -> EventTimeDate d;
    end;

eventRefTimeDate: WholeRef EventTime -> WholeRef Date;
eventRefTimeDate r = lensMapWhole eventTimeDate setEventTimeDate r;

eventRefTimeTimeOfDay: WholeRef EventTime -> WholeRef TimeOfDay;
eventRefTimeTimeOfDay r = let
    eventTimeTimeOfDay: Maybe EventTime -> Maybe TimeOfDay;
    eventTimeTimeOfDay met = case met of
        Just (EventTimeTime (LocalTime _ tod)) -> Just tod;
        _ -> Nothing;
        end;

    setEventTimeTimeOfDay: Maybe TimeOfDay -> Maybe EventTime -> Maybe (Maybe EventTime);
    setEventTimeTimeOfDay mtod met = Just $ case met of
        Nothing -> Nothing;
        Just et -> Just $ case mtod of
            Nothing -> EventTimeDate $ eventTimeDate et;
            Just tod -> EventTimeTime $ LocalTime (eventTimeDate et) tod;
            end;
        end;
    in maybeLensMapWhole eventTimeTimeOfDay setEventTimeTimeOfDay r;

# for ordering
eventTimeTime: EventTime -> LocalTime;
eventTimeTime et = case et of
    EventTimeDate d -> LocalTime d midnight;
    EventTimeTime t -> t
    end;

eventTimeOrder: Order EventTime;
eventTimeOrder = mapOrder eventTimeTime localChronological;


### Event

opentype Event;
events: FiniteSetRef Event;
events = property @Event @() !"type.event" !@ {()};

eventName = property @Event @Text !"identify.name";
eventTime = property @Event @EventTime !"event.time";
eventNotes = property @Event @Text !"item.description";

eventOrder: Order Event;
eventOrder = orderOn eventTime eventTimeOrder;

eventData: FiniteSetRef (EventTime,Text);
eventData = (eventTime !** eventName) !$$ events;

eventDataOrder: Order (EventTime,Text);
eventDataOrder = mapOrder fst eventTimeOrder;

eventList: WholeRef +[(EventTime,Text)];
eventList = members eventDataOrder eventData;


### UI

overviewRef: WholeRef +Text;
overviewRef = {textConcat $ mapList (\(t,n) -> showEventTime t <> ": " <> n <> "\n") %eventList};

overviewPage: (UI,UI);
overviewPage = (uiLabel {"Overview"},uiLabel overviewRef);

tablePage: WholeRef Event -> (UI,UI);
tablePage selection = let
    columns: [(WholeRef +Text, Event -> WholeRef Text)];
    columns = let
        timeColumn: (WholeRef +Text, Event -> WholeRef Text);
        timeColumn = ({"Time"},\e -> {showEventTime $ %(eventTime !$ {e})});
        nameColumn: (WholeRef +Text, Event -> WholeRef Text);
        nameColumn = ({"Name"},\e -> eventName !$ {e});
        in [timeColumn,nameColumn];
    in (uiLabel {"Events"}, uiListTable columns eventOrder events eventWindow (Just selection));

calendarWindow: Event -> Action Window;
calendarWindow evt = fixAction $ \window ->
    openWindow {"date of " <> %(eventName !$ {evt})} {[]} $ uiVertical
    [
        (False,uiCalendar $ eventRefTimeDate $ eventTime !$ {evt}),
        (False,uiButton {"Done: " <> toText %(eventRefTimeDate $ eventTime !$ {evt})} {closeWindow window})
    ];

eventWindow: Event -> Action Window;
eventWindow evt = stdWindow (eventName !$ {evt}) [] $ uiVertical
[
    (False, uiTextEntry $ eventName !$ {evt}),
    (False, uiHorizontal
    [
        (False, uiButton {"cal"} {calendarWindow evt}),
        (False, uiTextEntry $ interpretDateAsText $ eventRefTimeDate $ eventTime !$ {evt}),
        (False, uiTextEntry $ interpretTimeOfDayAsText $ eventRefTimeTimeOfDay $ eventTime !$ {evt})
    ]),
    (True, uiTextArea $ eventNotes !$ {evt})
];

newEventMenuItem: (Event -> Action ()) -> MenuItem;
newEventMenuItem setsel = menuAction ("New Event") (Just "Ctrl+K")
    {do
    item <- newOpenEntity @Event;
    day <- getDate;
    eventTime !$ {item} := EventTimeDate day;
    eventName !$ {item} := "";
    events += item;
    setsel item;
    end};

eventsWindow: Action Window;
eventsWindow = let
    iui selection = uiPages [overviewPage, tablePage selection];
    in selectionWindow "Events" events [newEventMenuItem] eventWindow iui;

in eventsWindow
