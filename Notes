1. Applications

1.1 Rich Text

operations:
display
selection -- could enforce tree-ness
insert/replace text

1.1.1 General
type RichText = [RichItem]
data RichItem = RIText Text | RIObject Object | RIStyled Style RichText

normalisation: glue successive RIText items
addressing?
conformance to schema, e.g. headings, paragraphs, etc.

1.1.2 Note style (paragraph-based)
data Note = MkNote NoteStyle [Paragraph] -- NonEmpty?
data Paragraph = NP ParagraphStyle [Item] -- NonEmpty?
data Item = ItemText TextStyle Text | ItemObject Object

NoteStyleNote (NoteStyle -> NoteStyle)
NoteReplaceParagraphs ParagraphSelection [Paragraph]
NoteStyleParagraphs ParagraphSelection (ParagraphStyle -> ParagraphStyle)
NoteReplaceItems ItemSelection [Item]
NoteStyleItems ItemSelection (TextStyle -> TextStyle)


data Styled style item = MkStyled style (NonEmpty item);
type Note = Styled NoteStyle Paragraph;
type Paragraph = Styled ParagraphStyle Run;
type Run = Styled RunStyle Item
data Item = TextItem Text | ObjectItem Object

1.2 Tabular

Row has a type; bag or list of rows, by key
Can combine tables, with editing., e.g. joins, unions

1.3 XML-like structures

data ListType (nil :: k) (cons :: k -> k -> k) (w :: k -> *) (t :: k) where
{
    NilListType :: ListType nil cons w nil;
    ConsListType :: w a -> ListType nil cons w t -> ListType nil cons w (cons a t);
};
type ProductListType = ListType () (,)
type SumListType = Never Either


data RepeatType (f :: * -> *) where
{
    RepeatOne :: RepeatType Identity; -- bijection
    RepeatZeroOrOne :: RepeatType Maybe; -- injection
    RepeatZeroOrMore :: RepeatType List; -- projection
    RepeatOneOrMore :: RepeatType NonEmpty; -- surjection
};

data NodeRepeatType (t :: *) where
{
    MkNNodeRepeatType :: RepeatType f -> SumList NamedNodeType t -> NodeRepeatType (f t);
};

data NodeType t where
{
    NTText :: NodeType Text
    NTStruct :: ProductListType NodeRepeatType t -> NodeType t
};

data NamedNodeType t = MkNamedNodeType String (NodeType t);

-- lens
NamedNodeType t -> t -> Node
NamedNodeType t -> Node -> Maybe t

toXmlDTD :: NamedNodeType t -> Text;

nodeTypeInfo :: NamedNodeType t -> Info t
nodeTypeType :: NamedNodeType (Any NamedNodeType)

class (EditSubject (DocumentTypeEdit t) ~ t, Edit (DocumentTypeEdit t), HasInfo t) => DocumentType t where
{
    type DocumentTypeEdit t :: *;
};

nodeDocumentType :: NamedNodeType t -> ConstraintWitness (DocumentType t)

! * + ?

(a|b|c)
(a,b)

ambiguous?
(x?,x?) = (((),Maybe x),Maybe x)

1.4 Graphs

from tabular data

[row]

each row is mark on graph

axis types, bijection with Double type, linear but otherwise arbitrary, i.e. torsor on 1D vector space
or categories, instances of Finite

1.5 A Type System

XML type system
JSON type system


1.6 Soup

A set of items identified by guid, all of the same type (typically a "container" type that can contain things of different types).

1.6.1 Storage

A directory with files named <guid>.xml (for XML files)
Index files, containing rows of (guid,val)

