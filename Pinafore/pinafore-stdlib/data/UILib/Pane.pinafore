import "pinafore-gnome", "UILib/Context" in
with GTK. in
namespace UILib of

    ### Useful GTK stuff
    namespace Element of
        #| Create a labelled page for use with `notebook.Element.GTK`.
        page: WholeModel +Text -> Element -> Element *: Element
        = fn n, ui => (label.Element n,ui);

        #| Create a labelled layout row.
        labelled: WholeModel +Text -> Element -> Element
        = fn n, ui => horizontal.Element [label.Element n, layoutGrow.Element ui];
    end;

    #| A menu entry for creating a new "item" (of type `q`).
    datatype NewItem +q of
        Mk of
            name: Text;
            mkey: Maybe Text = Nothing;
            newItem: Action q;
        end;
    end;

    #| A way of presenting some set of items as a `Pane`.
    datatype SetPresentation {-p,+q} of
        Mk of
            #| pane title
            title: Text;

            #| the set of items
            itemSet: SetModel p;

            #| menu items for creating new items
            newItems: List (NewItem q) = [];

            #| what to do when an item is activated
            itemOpenAction: p -> Action Unit;

            itemElement: WholeModel +p -> Element
            = fn _ => blank.Element;

            listElement: WholeModel {-q,+p} -> Element
            = fn _ => blank.Element;
        end;
    end;

    #| A pane is a title, GTK element, and menu.
    datatype Pane of
        Mk of
            titleModel: WholeModel Text;
            extraMenusModel: WholeModel (List MenuEntry);
            element: Element;
        end;
    end;

    namespace Pane of

        simple: Text -> Element -> Pane
        = fn title, element => let
            titleModel = {title};
            extraMenusModel = {[]};
            in Mk.Pane;

        #| A notebook from a list of panes
        notebook: WholeModel +Text -> List Pane -> Action Pane
        = fn title, panes => do
            tabModel <- newMem.WholeModel;
            pure $ let
                makePage: Pane -> Element *: Element
                = fn Mk.Pane => page.Element titleModel element;
                element: Element = notebook.Element tabModel $ map.List makePage panes;

                with WholeModel. end;
                itemsModel = for panes $ fn Mk.Pane => extraMenusModel;
                titleModel: WholeModel Text = immut title;
                extraMenusModel: WholeModel (List MenuEntry) = fromMaybe {index.List %itemsModel %tabModel};
                in Mk.Pane;
            end;

        presentWithElement: SetPresentation item -> (WholeModel item -> Element) -> Action Pane
        = fn Mk.SetPresentation, getElement => do
            selectionRef <- newMem.WholeModel;
            pure $ let
                viewItem: Action Unit
                = do
                    item <- get.WholeModel selectionRef;
                    itemOpenAction item;
                    pure ();
                    end;

                deleteItem: Action Unit
                = do
                    item <- get.WholeModel selectionRef;
                    itemSet -=.SetModel item;
                    end;

                newItemToMenuEntry = fn Mk.NewItem => action.MenuEntry name mkey
                    {do
                    item <- newItem;
                    itemSet +=.SetModel item;
                    selectionRef :=.WholeModel item;
                    end};

                extraMenus: List MenuEntry
                = with MenuEntry.GTK. in
                    [
                        submenu "Selection" $ map.List newItemToMenuEntry newItems <>.List
                        [
                            action "View" Nothing {viewItem},
                            action "Delete" Nothing {deleteItem}
                        ]
                    ];
                titleModel: WholeModel Text = {title};
                element: Element = getElement selectionRef;
                extraMenusModel: WholeModel (List MenuEntry) = {extraMenus};
                in Mk.Pane;
            end;

        presentList: SetPresentation item -> Action Pane
        = fn tp@Mk.SetPresentation =>
            presentWithElement tp $ fn selection => let
                sidebarUI: Element
                = listElement selection;

                selectedUI: Element
                = itemElement $ immut.WholeModel selection;

                in horizontal.Element [sidebarUI, layoutGrow.Element selectedUI];

        datatype Context <: Context.UILib of
            Mk of
                Mk.Context.UILib;
                #| A window that comes with some menus.
                stdWindow: WholeModel +Text -> WholeModel +(List MenuEntry) -> Element -> Action Window;
                paneWindow: Pane -> Action Window;
            end;
        end;

        mkContext: Context.UILib -> Context.Pane
        = fn Mk.Context.UILib => let
            stdWindow: WholeModel +Text -> WholeModel +(List MenuEntry) -> Element -> Action Window
            = fn title, extraMenus, contents => mfix.Action $ fn window => do
                textsel <- newMem.WholeModel;
                let
                    notify: Action TextModel -> Action Unit
                    = fn atmodel => textsel :=.WholeModel atmodel;

                    getTextModel: Action (WholeModel Text)
                    = do
                        atmodel <- get.WholeModel textsel;
                        atmodel;
                    end;

                    selCopy: Action Unit
                    = do
                        tmodel <- getTextModel;
                        text <- get.WholeModel tmodel;
                        clipboard gtk :=.WholeModel text;
                    end;

                    selCut: Action Unit
                    = do
                        tmodel <- getTextModel;
                        text <- get.WholeModel tmodel;
                        clipboard gtk :=.WholeModel text;
                        tmodel :=.WholeModel "";
                    end;

                    selPaste: Action Unit
                    = do
                        tmodel <- getTextModel;
                        clip <- get.WholeModel $ clipboard gtk;
                        clip >- match
                            text:? Text => tmodel :=.WholeModel text;
                            _ => pure ();
                        end;
                    end;

                    mbar: Element
                    = dynamic.Element
                        {menuBar.Element $ with MenuEntry.GTK. in [
                            submenu "File"
                            [
                                action "Close" (Just "Ctrl+W") {close.Window window},
                                separator,
                                action "Exit" (Just "Ctrl+Q") {exit gtk}
                            ],
                            submenu "Edit"
                            [
                                action "Undo" (Just "Ctrl+Z") {queueUndo undoHandler},
                                action "Redo" (Just "Ctrl+Y") {queueRedo undoHandler},
                                separator,
                                action "Cut" (Just "Ctrl+X") {selCut},
                                action "Copy" (Just "Ctrl+C") {selCopy},
                                action "Paste" (Just "Ctrl+V") {selPaste}
                            ]
                        ] <>.List %extraMenus};
                    in open.Window gtk (600,800) title $ vertical.Element [mbar, layoutGrow.Element $ scrolled.Element $ notifySelection.Element notify contents];
                end;

                paneWindow: Pane -> Action Window
                = fn Mk.Pane => stdWindow titleModel extraMenusModel element;
            in Mk.Context.Pane;

    end;

end;
