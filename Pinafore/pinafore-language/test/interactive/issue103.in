let f: ((a -> a) & b) -> Maybe b = Just
let i: a -> a = fn x => x;
:type f
:type i
:type f i

let g: ((a -> a) & b) -> b = fn x => x
:type g
:type g i

let ur: WholeRef a -> Unit = fn _ => ()
:type ur
:type newMemWhole >>= fn ref => return (ref, ())
:type newMemWhole >>= fn ref => return (ref, ((fn _ => ()) : WholeRef a -> Unit) ref)
:type fn ref => return (ref, ur ref)
:type newMemWhole >>= fn ref => return (ref, ur ref)
