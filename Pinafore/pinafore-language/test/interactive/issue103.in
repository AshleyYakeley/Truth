let f: ((a -> a) & b) -> Maybe b; f = Just
let i: a -> a; i x = x;
:type f
:type i
:type f i

let g: ((a -> a) & b) -> b; g x = x
:type g
:type g i

let ur: WholeRef a -> Unit; ur _ = ()
:type ur
:type newMemWhole >>= fn ref => return (ref, ())
:type newMemWhole >>= fn ref => return (ref, ((fn _ => ()) : WholeRef a -> Unit) ref)
:type fn ref => return (ref, ur ref)
:type newMemWhole >>= fn ref => return (ref, ur ref)
