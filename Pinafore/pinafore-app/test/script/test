#!/usr/bin/pinafore
import "pinafore-media", "pinafore-gnome" in
openDefaultStore.Env >>= fn dstore =>
new.UndoHandler >>= fn uh =>
handleStore.UndoHandler uh dstore >>= fn store =>
with GTK., Store. in
run $ fn gtk =>
let

### Useful
ui_page = fn n, ui => (label.Element n,ui);
ui_labelled = fn n, ui => horizontal.Element [label.Element n, layoutGrow.Element  ui];

std_window: WholeModel +Text -> Element -> Action Window
= fn title, contents => mfix.Action $ fn window => let
    mbar: Element
    = menuBar.Element
        [
            submenu.MenuEntry "File"
            [
                action.MenuEntry "Close" (Just "Ctrl+W") {close.Window window},
                separator.MenuEntry,
                action.MenuEntry "Exit" (Just "Ctrl+Q") {exit gtk}
            ],
            submenu.MenuEntry "Edit"
            [
                action.MenuEntry "Undo" (Just "Ctrl+Z") {queueUndo.UndoHandler uh},
                action.MenuEntry "Redo" (Just "Ctrl+Y") {queueRedo.UndoHandler uh}
            ]
        ]
    in open.Window gtk (400,600) title $ vertical.Element [mbar, layoutGrow.Element $ scrolled.Element contents];

### People

# Ontology

opentype Person;

people = property @Person @Unit !"f06efa5e-190f-4e5d-8633-495c5683c124" store !@ {()};

name = property @Person @Text !"498260df-6a8a-44f0-b285-68a63565a33b" store;


mother = property @Person @Person !"3afce58f-b7eb-4b11-8a75-2d66afd4d085" store;
father = property @Person @Person !"c005705f-9259-4d24-9713-db28a6e4f7d5" store;
# parents : WholeModel Person -> FiniteSetModel Person;
# parents p = (mother !$ p) <|> (father !$ p);
children : WholeModel Person -> FiniteSetModel Person
= fn p => mother !@ p <:|:> father !@ p;

employer = property @Person @Person !"72f612af-ae47-4c18-b3df-6932ae914f62" store;

email = property @Person @Text !"8649b74c-123e-4ece-be3b-b734b0db3ea7" store;

phone = property @Person @Text !"83dfc88b-7b5b-4262-a548-0af84d5e3b63" store;

opentype Location;
home = property @Person @Location !"b4f7736e-2db4-486c-aae5-b6a9b1035fd0" store;
address = property @Location @Text !"fd83bef7-145c-4e40-a2d6-938bb5fb6da1" store;
locphone = property @Location @Text !"0689535c-f220-47a2-8fcb-4782574e0749" store;
city = property @Location @Text !"55c84133-64f2-47a6-8b3c-e01256ec9779" store;
postcode = property @Location @Text !"80f99100-407b-4a6b-a4f0-a025c94132b3" store;
province = property @Location @Text !"dffae424-28d5-4543-b1b2-b8a744bbc0cd" store;
country = property @Location @Text !"1257c340-0ec1-4ff7-9fd8-d2eaa7822463" store;

birthdate = property @Person @Text !"b711b9b3-b43c-4ff6-be12-3291cc6b050a" store;
deathdate = property @Person @Text !"805a9e65-d69a-4261-9c94-a3249885b6bb" store;
married = property @Person @Boolean !"380ac576-9252-4783-b2d8-db222c683a22" store;

# GTK
let rec
ui_people : FiniteSetModel Person -> Element
= fn pp => exec.Element $ do
    selectedperson <- newMem.WholeModel;
    pplist <- getList.FiniteSetModel empty.Order pp;
    pure $ vertical.Element
    [
        button.Element {"New Person"} {do p <- new.OpenEntity @Person; pp += p; window_person p end},
        button.Element {"View Person"} {get selectedperson >>= window_person},
        button.Element {"Remove Person"} {get selectedperson >>= fn p => pp -= p},
        layoutGrow.Element $ listTable.Element [({"Name"},fn p => name !$ {p})] pplist window_person (Just selectedperson)
    ];
    end;

peopleByName : WholeModel +(List (Person *: Text))
= toList.FiniteSetModel (map.ModelOrder fst $ on.ModelOrder name alphabetical) $ (id.Property **.Property name) !$$ people;

ui_person : WholeModel Person -> Element
= fn p => vertical.Element
[
    ui_labelled {"Name: "} $ textEntry.Element $ name !$ p,
    layoutGrow.Element $ notebook.Element unknown
    [
        ui_page {"Social"} $ vertical.Element
        [
            ui_labelled {"Email: "} $ textEntry.Element $ email !$ p,
            ui_labelled {"Phone: "} $ textEntry.Element $ phone !$ p
        ],
        ui_page {"Home"} $ let homep = home !$ p in vertical.Element
        [
            ui_labelled {"Address: "} $ textArea.Element (fromWhole.TextModel $ address !$ homep),
            ui_labelled {"City: "} $ textEntry.Element $ city !$ homep,
            ui_labelled {"Postcode/ZIP: "} $ textEntry.Element $ postcode !$ homep,
            ui_labelled {"State/Province: "} $ textEntry.Element $ province !$ homep,
            ui_labelled {"Country: "} $ textEntry.Element $ country !$ homep,
            ui_labelled {"Phone: "} $ textEntry.Element $ locphone !$ homep
        ],
        ui_page {"Work"} $ vertical.Element
        [
            ui_labelled {"Employer: "} $ textEntry.Element $ (name ..Property employer) !$ p
        ],
        ui_page {"Family"} $ vertical.Element
        [
            ui_labelled {"Birth: "} $ textEntry.Element $ birthdate !$ p,
            ui_labelled {"Death: "} $ textEntry.Element $ deathdate !$ p,
            checkBox.Element {"Married"} $ married !$ p,
            ui_labelled {"Mother: "} $ pick.Element peopleByName $ mother !$ p,
            ui_labelled {"Father: "} $ pick.Element peopleByName $ father !$ p,
            layoutGrow.Element $ ui_people (children p)
        ]
    ]
];

window_person : Person -> Action Window
= fn p => std_window (name !$ {p}) (ui_person {p});

window_people : Action Window
= std_window {"People"} (ui_people people);
end;

### Calculator

window_calc : Action Window
= let
    opentype P;
    pvalue = property @P @Number !"pvalue" store;
    aval = pvalue !$ {point.OpenEntity @P !"a4706230-2c61-44b1-b600-516e7a54c607"};
    bval = pvalue !$ {point.OpenEntity @P !"9d284ad2-e141-4114-ae50-8829a6db710f"};
    in std_window {"Calc"} $ vertical.Element
    [
        #textEntry.Element aval,
        #textEntry.Element bval,
        #label.Element $ aval / bval
    ];

### Switching Value

window_switch : Action Window
= let
    opentype P;
    pbool = property @P @Boolean !"pbool" store;
    ptext = property @P @Text !"ptext" store;
    sw_pick = pbool !$ {point.OpenEntity @P !"59eb2d87-f815-47ef-b7dc-8fe434151bb6"};
    sw_val1 = ptext !$ {point.OpenEntity @P !"6d9f7afa-1091-49cc-8646-8e613bb75ee5"};
    sw_val2 = ptext !$ {point.OpenEntity @P !"934712ae-73a7-4084-8a43-d618c737fd56"};
    in std_window {"Switch"} $ vertical.Element
    [
        #textEntry.Element sw_pick),
        checkBox.Element {"pick"} sw_pick,
        layoutGrow.Element $ dynamic.Element {if %sw_pick then textArea.Element (fromWhole.TextModel sw_val1) else textArea.Element (fromWhole.TextModel sw_val2)}
    ];

### Imported Files

window_files : Action Window
= let
    #Files = @type !f649e7d7-7e98-4c86-919c-34f52ac12c7a;
    #caption = %4a8ca041-a67d-4a1e-b212-9243fca635b0;
    window_file = fn f => std_window {"File"} $ vertical.Element
    [
        #textEntry.Element $ caption f
    ];
    in std_window {"Files"} $ vertical.Element
    [
        #button.Element "Import" {file_import Files $ fn f => std_window $ window_file f},
        #layoutGrow.Element $ listTable.Element [column "Caption" caption, column "Size" file_size] window_file Files
    ];

### Constant Edit

window_constant : Action Window
= std_window {"Constant"} $ vertical.Element
[
    checkBox.Element {"off"} {False},
    checkBox.Element {"on"} {True},
    textEntry.Element {"constant"},
    layoutGrow.Element $ textArea.Element (fromWhole.TextModel $ {"constant"})
];

### CSS
window_css: Action Window
= do
    cssref <- newMem.TextModel;
    cssref := ".y, .y > text {color:green; font-family: \"serif\";}";
    sometext <- newMem.WholeModel;
    sometext := "whatever";
    std_window {"CSS"} $ styleSheet.Element (ignoreUpdateUIExceptions.GTK.Debug. cssref) $ name.Element "root" $ vertical.Element
        [
            styleClass.Element "x" $ name.Element "A" $ checkBox.Element {"Box"} {True},
            styleClass.Element "x" $ name.Element "B" $ button.Element {"Button"} {do pure () end},
            styleClass.Element "x" $ name.Element "C" $ textEntry.Element sometext,
            layoutGrow.Element $ styleClass.Element "y" $ name.Element "D" $ textArea.Element cssref,
            styleClass.Element "y" $ name.Element "E" $ label.Element {"Some Text"}
        ];
    end;

### Drawing
window_drawing: WholeModel +Time -> Action Window
= fn now =>
    with Colour, Cairo, Drawing.Cairo, Path.Cairo, Number in
    do
        tzref <- newTimeZoneModel.LocalTime now;
        std_window {"Drawing"} $ draw.Element {fn (w,h) => let
            size = min w h;
            in fromTime.LocalTime %tzref %now >- match
                DateAndTime _ (HourMinuteSecond _ _ s) =>
                    translate (w / 2, h / 2) $
                    scale (size, size) $
                    scale (-0.5, -0.5) $
                    rotate (s * pi / 30) $
                    over.Operator $
                    source purple $
                    capSquare $
                    width 0.01 $
                    stroke $ concat.Path [moveTo (0, 0), lineTo (0, 1)];
                end};
    end;

window_list: Action Window
= do
    peopleList <- getList.FiniteSetModel (on.ModelOrder name alphabetical) people;
    std_window {"List"} $ list.Element ui_person peopleList;
    end;

### Text Selection
window_textselection: Action Window
= do
    tref1 <- newMem.TextModel;
    tref1 := "111";
    tref2 <- newMem.TextModel;
    tref2 := "222";
    tref3 <- newMem.TextModel;
    tref3 := "333";
    sel <- newMem.WholeModel;
    let
        notify: Action TextModel -> Action Unit
        = fn atref => sel := atref;
    in std_window {"Text Selection"} $ styleSheet.Element {"* {padding: 2pt;}"} $ vertical.Element
    [
        notifySelection.Element notify $ textArea.Element tref1,
        notifySelection.Element notify $ textArea.Element tref2,
        notifySelection.Element notify $ textArea.Element tref3,
        dynamic.Element {exec.Element $ map.Action (fn tref => textArea.Element (fromWhole.TextModel tref)) %sel}
    ];
    end;

### Cairo Image
window_cairoimage: Action Window
= with Colour, Cairo, Drawing.Cairo, Path.Cairo, Number, Element in
    let
    dimensions: Integer *: Integer
    = (400,400);
    drawing: Integer *: Integer -> Drawing Handler
    = fn (w,h) => let
        size = min w h;
        square: Drawing Handler
        = fill $ concat.Path [moveTo (0, 0), lineTo (0, 1), lineTo (1, 1), lineTo (1, 0), lineTo (0, 0)];
        squares: List ((Integer *: Integer) *: Colour)
        =
        [
            ((0,0), black),
            ((1,0), red),
            ((2,0), green),
            ((3,0), yellow),
            ((0,1), blue),
            ((1,1), magenta),
            ((2,1), cyan),
            ((3,1), white),
            ((0,2), purple),
            ((1,2), brown),
            ((2,2), pink),
            ((3,2), cornflowerblue),
            ((0,3), lavender),
            ((1,3), ivory),
            ((2,3), midnightblue)
        ];
        block: Number -> Drawing Handler
        = fn a => concat.Drawing
        [
            concat.Drawing $ map.List (fn (s,c) => translate s $ source (MkF.AlphaColour a c) $ square) squares,
            width 0.05 $ source black $ stroke $ arc (2,2) 2 0 (2 * pi)
        ];
        in
            scale (size, size) $
            scale (0.125, 0.125) $
            over.Operator $ concat.Drawing
            [
                translate (0,0) $ block 1,
                translate (0,4) $ block (2/3),
                translate (4,0) $ block (1/3),
                translate (4,4) $ block 0
            ];
    in std_window {"Cairo Image"} $ vertical
    [
        layoutGrow $ draw {drawing},
        layoutGrow $ styleSheet {"* {border: solid 5px black;padding: 5px;}"} $ image {toImage dimensions $ drawing dimensions}
    ];

### Start Window

let rec
window_start : Action Window
= do
    now <- newClock $ Seconds 1;
    timeZone <- newTimeZoneModel.LocalTime now;
    let
        utcDate = {%now};
        localNow = {fromTime.LocalTime %timeZone %now};
        today = {%localNow >- match DateAndTime day _ => day end};
        in do
        std_window {"Pinafore"} $ vertical.Element
        [
            label.Element {"UTC time: " <>.Text show %now},
            label.Element {"UTC date: " <>.Text show %utcDate},
            label.Element {"Local time: " <>.Text show %localNow},
            label.Element {"Local date: " <>.Text show %today},
            label.Element {"Time zone offset minutes: " <>.Text show %timeZone},
            button.Element {"Calculated Form"} {window_calc},
            button.Element {"Switch"} {window_switch},
            button.Element {"Files"} {window_files},
            button.Element {"Constant"} {window_constant},
            button.Element {"CSS"} {window_css},
            button.Element {"Drawing"} {window_drawing now},
            button.Element {"List"} {window_list},
            button.Element {"Text Selection"} {window_textselection},
            button.Element {"Disabled"} unknown,
            button.Element {"Unowned self"} {window_start},
            owned.Element $ button.Element {"Owned Self"} {window_start},
            button.Element {"Cairo Image"} {window_cairoimage},
            layoutGrow.Element $ blank.Element
        ];
        end;
    end;
end;

in window_start
