#!/usr/bin/pinafore
let
import "pinafore-media";
import "pinafore-gnome";
in
openDefaultStore.Env >>= fn dstore =>
newUndoHandler.UndoHandler >>= fn uh =>
handleStore.UndoHandler uh dstore >>= fn store =>
run.GTK $ fn gtk => let
using Store;

### Useful
ui_page = fns n ui => (label.GTK n,ui);
ui_labelled = fns n ui => horizontal.GTK [label.GTK n, layoutGrow.GTK  ui];

std_window: WholeModel +Text -> Element.GTK -> Action Window.GTK
= fns title contents => fixAction $ fn window => let
    mbar: Element.GTK
    = menuBar.GTK
        [
            menuSubmenu.GTK "File"
            [
                menuAction.GTK "Close" (Just "Ctrl+W") {close.Window.GTK window},
                menuSeparator.GTK,
                menuAction.GTK "Exit" (Just "Ctrl+Q") {exit.GTK gtk}
            ],
            menuSubmenu.GTK "Edit"
            [
                menuAction.GTK "Undo" (Just "Ctrl+Z") {queueUndo.UndoHandler uh},
                menuAction.GTK "Redo" (Just "Ctrl+Y") {queueRedo.UndoHandler uh}
            ]
        ]
    in open.Window.GTK gtk (400,600) title $ vertical.GTK [mbar, layoutGrow.GTK $ scrolled.GTK contents];

### People

# Ontology

opentype Person;

people = property @Person @Unit !"f06efa5e-190f-4e5d-8633-495c5683c124" store !@ {()};

name = property @Person @Text !"498260df-6a8a-44f0-b285-68a63565a33b" store;


mother = property @Person @Person !"3afce58f-b7eb-4b11-8a75-2d66afd4d085" store;
father = property @Person @Person !"c005705f-9259-4d24-9713-db28a6e4f7d5" store;
# parents : WholeModel Person -> FiniteSetModel Person;
# parents p = (mother !$ p) <|> (father !$ p);
children : WholeModel Person -> FiniteSetModel Person
= fn p => mother !@ p <:|:> father !@ p;

employer = property @Person @Person !"72f612af-ae47-4c18-b3df-6932ae914f62" store;

email = property @Person @Text !"8649b74c-123e-4ece-be3b-b734b0db3ea7" store;

phone = property @Person @Text !"83dfc88b-7b5b-4262-a548-0af84d5e3b63" store;

opentype Location;
home = property @Person @Location !"b4f7736e-2db4-486c-aae5-b6a9b1035fd0" store;
address = property @Location @Text !"fd83bef7-145c-4e40-a2d6-938bb5fb6da1" store;
locphone = property @Location @Text !"0689535c-f220-47a2-8fcb-4782574e0749" store;
city = property @Location @Text !"55c84133-64f2-47a6-8b3c-e01256ec9779" store;
postcode = property @Location @Text !"80f99100-407b-4a6b-a4f0-a025c94132b3" store;
province = property @Location @Text !"dffae424-28d5-4543-b1b2-b8a744bbc0cd" store;
country = property @Location @Text !"1257c340-0ec1-4ff7-9fd8-d2eaa7822463" store;

birthdate = property @Person @Text !"b711b9b3-b43c-4ff6-be12-3291cc6b050a" store;
deathdate = property @Person @Text !"805a9e65-d69a-4261-9c94-a3249885b6bb" store;
married = property @Person @Boolean !"380ac576-9252-4783-b2d8-db222c683a22" store;

# GTK
rec
ui_people : FiniteSetModel Person -> Element.GTK
= fn pp => exec.GTK $ do
    selectedperson <- newMem.WholeModel;
    pplist <- getList.FiniteSetModel empty.Order pp;
    return $ vertical.GTK
    [
        button.GTK {"New Person"} {do p <- newOpenEntity @Person; pp += p; window_person p end},
        button.GTK {"View Person"} {get selectedperson >>= window_person},
        button.GTK {"Remove Person"} {get selectedperson >>= fn p => pp -= p},
        layoutGrow.GTK $ listTable.GTK [({"Name"},fn p => name !$ {p})] pplist window_person (Just selectedperson)
    ];
    end;

peopleByName : WholeModel +(List (Person *: Text))
= list.FiniteSetModel (mapOrder fst $ on.ModelOrder name alphabetical) $ (identity **.Property name) !$$ people;

ui_person : WholeModel Person -> Element.GTK
= fn p => vertical.GTK
[
    ui_labelled {"Name: "} $ textEntry.GTK $ name !$ p,
    layoutGrow.GTK $ notebook.GTK unknown
    [
        ui_page {"Social"} $ vertical.GTK
        [
            ui_labelled {"Email: "} $ textEntry.GTK $ email !$ p,
            ui_labelled {"Phone: "} $ textEntry.GTK $ phone !$ p
        ],
        ui_page {"Home"} $ let homep = home !$ p in vertical.GTK
        [
            ui_labelled {"Address: "} $ textArea.GTK (wholeModelText $ address !$ homep),
            ui_labelled {"City: "} $ textEntry.GTK $ city !$ homep,
            ui_labelled {"Postcode/ZIP: "} $ textEntry.GTK $ postcode !$ homep,
            ui_labelled {"State/Province: "} $ textEntry.GTK $ province !$ homep,
            ui_labelled {"Country: "} $ textEntry.GTK $ country !$ homep,
            ui_labelled {"Phone: "} $ textEntry.GTK $ locphone !$ homep
        ],
        ui_page {"Work"} $ vertical.GTK
        [
            ui_labelled {"Employer: "} $ textEntry.GTK $ (..Property name employer) !$ p
        ],
        ui_page {"Family"} $ vertical.GTK
        [
            ui_labelled {"Birth: "} $ textEntry.GTK $ birthdate !$ p,
            ui_labelled {"Death: "} $ textEntry.GTK $ deathdate !$ p,
            checkBox.GTK {"Married"} $ married !$ p,
            ui_labelled {"Mother: "} $ pick.GTK peopleByName $ mother !$ p,
            ui_labelled {"Father: "} $ pick.GTK peopleByName $ father !$ p,
            layoutGrow.GTK $ ui_people (children p)
        ]
    ]
];

window_person : Person -> Action Window.GTK
= fn p => std_window (name !$ {p}) (ui_person {p});

window_people : Action Window.GTK
= std_window {"People"} (ui_people people);
end;

### Calculator

window_calc : Action Window.GTK
= let
    opentype P;
    pvalue = property @P @Number !"pvalue" store;
    aval = pvalue !$ {openEntity @P !"a4706230-2c61-44b1-b600-516e7a54c607"};
    bval = pvalue !$ {openEntity @P !"9d284ad2-e141-4114-ae50-8829a6db710f"};
    in std_window {"Calc"} $ vertical.GTK
    [
        #textEntry.GTK aval,
        #textEntry.GTK bval,
        #label.GTK $ aval / bval
    ];

### Switching Value

window_switch : Action Window.GTK
= let
    opentype P;
    pbool = property @P @Boolean !"pbool" store;
    ptext = property @P @Text !"ptext" store;
    sw_pick = pbool !$ {openEntity @P !"59eb2d87-f815-47ef-b7dc-8fe434151bb6"};
    sw_val1 = ptext !$ {openEntity @P !"6d9f7afa-1091-49cc-8646-8e613bb75ee5"};
    sw_val2 = ptext !$ {openEntity @P !"934712ae-73a7-4084-8a43-d618c737fd56"};
    in std_window {"Switch"} $ vertical.GTK
    [
        #textEntry.GTK sw_pick),
        checkBox.GTK {"pick"} sw_pick,
        layoutGrow.GTK $ dynamic.GTK {if %sw_pick then textArea.GTK (wholeModelText sw_val1) else textArea.GTK (wholeModelText sw_val2)}
    ];

### Imported Files

window_files : Action Window.GTK
= let
    #Files = @type !f649e7d7-7e98-4c86-919c-34f52ac12c7a;
    #caption = %4a8ca041-a67d-4a1e-b212-9243fca635b0;
    window_file = fn f => std_window {"File"} $ vertical.GTK
    [
        #textEntry.GTK $ caption f
    ];
    in std_window {"Files"} $ vertical.GTK
    [
        #button.GTK "Import" {file_import Files $ fn f => std_window $ window_file f},
        #layoutGrow.GTK $ listTable.GTK [column "Caption" caption, column "Size" file_size] window_file Files
    ];

### Constant Edit

window_constant : Action Window.GTK
= std_window {"Constant"} $ vertical.GTK
[
    checkBox.GTK {"off"} {False},
    checkBox.GTK {"on"} {True},
    textEntry.GTK {"constant"},
    layoutGrow.GTK $ textArea.GTK (wholeModelText $ {"constant"})
];

### CSS
window_css: Action Window.GTK
= do
    cssref <- newMem.TextModel;
    cssref := ".y, .y > text {color:green; font-family: \"serif\";}";
    sometext <- newMem.WholeModel;
    sometext := "whatever";
    std_window {"CSS"} $ styleSheet.GTK (ignoreUpdateUIExceptions.GTK.Debug cssref) $ name.GTK "root" $ vertical.GTK
        [
            styleClass.GTK "x" $ name.GTK "A" $ checkBox.GTK {"Box"} {True},
            styleClass.GTK "x" $ name.GTK "B" $ button.GTK {"Button"} {return ()},
            styleClass.GTK "x" $ name.GTK "C" $ textEntry.GTK sometext,
            layoutGrow.GTK $ styleClass.GTK "y" $ name.GTK "D" $ textArea.GTK cssref,
            styleClass.GTK "y" $ name.GTK "E" $ label.GTK {"Some Text"}
        ];
    end;

### Drawing
window_drawing: WholeModel +Time -> Action Window.GTK
= fn now => let using Colour; using Cairo in do
    tzref <- newTimeZoneModel now;
    std_window {"Drawing"} $ draw.GTK {fn (w,h) => let
        size = min w h;
        in timeToLocal %tzref %now >- match
            DateAndTime _ (HourMinuteSecond _ _ s) =>
                translate (w / 2, h / 2) $
                scale (size, size) $
                scale (-0.5, -0.5) $
                rotate (s ~* pi ~/ 30) $
                operatorOver $
                source purple $
                lineCapSquare $
                lineWidth 0.01 $
                stroke $ concatPath [moveTo (0, 0), lineTo (0, 1)];
            end};
    end;

window_list: Action Window.GTK
= do
    peopleList <- getList.FiniteSetModel (on.ModelOrder name alphabetical) people;
    std_window {"List"} $ list.GTK ui_person peopleList;
    end;

### Text Selection
window_textselection: Action Window.GTK
= do
    tref1 <- newMem.TextModel;
    tref1 := "111";
    tref2 <- newMem.TextModel;
    tref2 := "222";
    tref3 <- newMem.TextModel;
    tref3 := "333";
    sel <- newMem.WholeModel;
    let
        notify: Action TextModel -> Action Unit
        = fn atref => sel := atref;
    in std_window {"Text Selection"} $ styleSheet.GTK {"* {padding: 2pt;}"} $ vertical.GTK
    [
        notifySelection.GTK notify $ textArea.GTK tref1,
        notifySelection.GTK notify $ textArea.GTK tref2,
        notifySelection.GTK notify $ textArea.GTK tref3,
        dynamic.GTK {exec.GTK $ mapAction (fn tref => textArea.GTK (wholeModelText tref)) %sel}
    ];
    end;

### Cairo Image
window_cairoimage: Action Window.GTK
= let
    using Colour;
    using Cairo;
    using GTK;
    dimensions: Integer *: Integer
    = (400,400);
    drawing: Integer *: Integer -> Drawing Handler
    = fn (w,h) => let
        size = min w h;
        square: Drawing Handler
        = fill $ concatPath [moveTo (0, 0), lineTo (0, 1), lineTo (1, 1), lineTo (1, 0), lineTo (0, 0)];
        squares: List ((Integer *: Integer) *: Colour)
        =
        [
            ((0,0), black),
            ((1,0), red),
            ((2,0), green),
            ((3,0), yellow),
            ((0,1), blue),
            ((1,1), magenta),
            ((2,1), cyan),
            ((3,1), white),
            ((0,2), purple),
            ((1,2), brown),
            ((2,2), pink),
            ((3,2), cornflowerblue),
            ((0,3), lavender),
            ((1,3), ivory),
            ((2,3), midnightblue)
        ];
        block: Number -> Drawing Handler
        = fn a => concatDrawing
        [
            concatDrawing $ mapList (fn (s,c) => translate s $ source (MkAlphaColourFraction a c) $ square) squares,
            lineWidth 0.05 $ source black $ stroke $ arc (2,2) 2 0 (2 ~* pi)
        ];
        in
            scale (size, size) $
            scale (0.125, 0.125) $
            operatorOver $ concatDrawing
            [
                translate (0,0) $ block 1,
                translate (0,4) $ block (2/3),
                translate (4,0) $ block (1/3),
                translate (4,4) $ block 0
            ];
    in std_window {"Cairo Image"} $ vertical
    [
        layoutGrow $ draw {drawing},
        layoutGrow $ styleSheet {"* {border: solid 5px black;padding: 5px;}"} $ image {drawToImage dimensions $ drawing dimensions}
    ];

### Start Window

rec
window_start : Action Window.GTK
= do
    now <- newClock $ Seconds 1;
    timeZone <- newTimeZoneModel now;
    let
        utcDate = {%now};
        localNow = {timeToLocal %timeZone %now};
        today = {%localNow >- match DateAndTime day _ => day end};
        in do
        std_window {"Pinafore"} $ vertical.GTK
        [
            label.GTK {"UTC time: " <> show %now},
            label.GTK {"UTC date: " <> show %utcDate},
            label.GTK {"Local time: " <> show %localNow},
            label.GTK {"Local date: " <> show %today},
            label.GTK {"Time zone offset minutes: " <> show %timeZone},
            button.GTK {"Calculated Form"} {window_calc},
            button.GTK {"Switch"} {window_switch},
            button.GTK {"Files"} {window_files},
            button.GTK {"Constant"} {window_constant},
            button.GTK {"CSS"} {window_css},
            button.GTK {"Drawing"} {window_drawing now},
            button.GTK {"List"} {window_list},
            button.GTK {"Text Selection"} {window_textselection},
            button.GTK {"Disabled"} unknown,
            button.GTK {"Unowned self"} {window_start},
            owned.GTK $ button.GTK {"Owned Self"} {window_start},
            button.GTK {"Cairo Image"} {window_cairoimage},
            layoutGrow.GTK $ blank.GTK
        ];
        end;
    end;
end;

in window_start
