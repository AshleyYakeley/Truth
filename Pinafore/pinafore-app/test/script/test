#!/usr/bin/pinafore
let
import "pinafore-media";
import "pinafore-gnome";
in
GTK.run $ fn gtk => let

### Useful
ui_page = fns n ui => (GTK.label n,ui);
ui_labelled = fns n ui => GTK.horizontal [GTK.label n, GTK.layoutGrow  ui];

std_window: WholeModel +Text -> GTK.Element -> Action GTK.Window
= fns title contents => fixAction $ fn window => let
    mbar: GTK.Element
    = GTK.menuBar
        [
            GTK.menuSubmenu "File"
            [
                GTK.menuAction "Close" (Just "Ctrl+W") {GTK.closeWindow window},
                GTK.menuSeparator,
                GTK.menuAction "Exit" (Just "Ctrl+Q") {GTK.exit gtk}
            ],
            GTK.menuSubmenu "Edit"
            [
                GTK.menuAction "Undo" (Just "Ctrl+Z") {queueUndo},
                GTK.menuAction "Redo" (Just "Ctrl+Y") {queueRedo}
            ]
        ]
    in GTK.openWindow gtk (400,600) title $ GTK.vertical [mbar, GTK.layoutGrow $ GTK.scrolled contents];

### People

# Ontology

opentype Person;

people = property @Person @Unit !"f06efa5e-190f-4e5d-8633-495c5683c124" !@ {()};

name = property @Person @Text !"498260df-6a8a-44f0-b285-68a63565a33b";


mother = property @Person @Person !"3afce58f-b7eb-4b11-8a75-2d66afd4d085";
father = property @Person @Person !"c005705f-9259-4d24-9713-db28a6e4f7d5";
# parents : WholeModel Person -> FiniteSetModel Person;
# parents p = (mother !$ p) <|> (father !$ p);
children : WholeModel Person -> FiniteSetModel Person
= fn p => mother !@ p <:|:> father !@ p;

employer = property @Person @Person !"72f612af-ae47-4c18-b3df-6932ae914f62";

email = property @Person @Text !"8649b74c-123e-4ece-be3b-b734b0db3ea7";

phone = property @Person @Text !"83dfc88b-7b5b-4262-a548-0af84d5e3b63";

opentype Location;
home = property @Person @Location !"b4f7736e-2db4-486c-aae5-b6a9b1035fd0";
address = property @Location @Text !"fd83bef7-145c-4e40-a2d6-938bb5fb6da1";
locphone = property @Location @Text !"0689535c-f220-47a2-8fcb-4782574e0749";
city = property @Location @Text !"55c84133-64f2-47a6-8b3c-e01256ec9779";
postcode = property @Location @Text !"80f99100-407b-4a6b-a4f0-a025c94132b3";
province = property @Location @Text !"dffae424-28d5-4543-b1b2-b8a744bbc0cd";
country = property @Location @Text !"1257c340-0ec1-4ff7-9fd8-d2eaa7822463";

birthdate = property @Person @Text !"b711b9b3-b43c-4ff6-be12-3291cc6b050a";
deathdate = property @Person @Text !"805a9e65-d69a-4261-9c94-a3249885b6bb";
married = property @Person @Boolean !"380ac576-9252-4783-b2d8-db222c683a22";

# GTK
rec
ui_people : FiniteSetModel Person -> GTK.Element
= fn pp => GTK.exec $ do
    selectedperson <- newMemWholeModel;
    pplist <- getFiniteSetModelList noOrder pp;
    return $ GTK.vertical
    [
        GTK.button {"New Person"} {do p <- newOpenEntity @Person; pp += p; window_person p end},
        GTK.button {"View Person"} {get selectedperson >>= window_person},
        GTK.button {"Remove Person"} {get selectedperson >>= fn p => pp -= p},
        GTK.layoutGrow $ GTK.listTable [({"Name"},fn p => name !$ {p})] pplist window_person (Just selectedperson)
    ];
    end;

peopleByName : WholeModel +(List (Person *: Text))
= finiteSetModelList (mapOrder fst $ orderOn name alphabetical) $ (identity !** name) !$$ people;

ui_person : WholeModel Person -> GTK.Element
= fn p => GTK.vertical
[
    ui_labelled {"Name: "} $ GTK.textEntry $ name !$ p,
    GTK.layoutGrow $ GTK.notebook unknown
    [
        ui_page {"Social"} $ GTK.vertical
        [
            ui_labelled {"Email: "} $ GTK.textEntry $ email !$ p,
            ui_labelled {"Phone: "} $ GTK.textEntry $ phone !$ p
        ],
        ui_page {"Home"} $ let homep = home !$ p in GTK.vertical
        [
            ui_labelled {"Address: "} $ GTK.textArea (wholeModelText $ address !$ homep),
            ui_labelled {"City: "} $ GTK.textEntry $ city !$ homep,
            ui_labelled {"Postcode/ZIP: "} $ GTK.textEntry $ postcode !$ homep,
            ui_labelled {"State/Province: "} $ GTK.textEntry $ province !$ homep,
            ui_labelled {"Country: "} $ GTK.textEntry $ country !$ homep,
            ui_labelled {"Phone: "} $ GTK.textEntry $ locphone !$ homep
        ],
        ui_page {"Work"} $ GTK.vertical
        [
            ui_labelled {"Employer: "} $ GTK.textEntry $ (name !. employer) !$ p
        ],
        ui_page {"Family"} $ GTK.vertical
        [
            ui_labelled {"Birth: "} $ GTK.textEntry $ birthdate !$ p,
            ui_labelled {"Death: "} $ GTK.textEntry $ deathdate !$ p,
            GTK.checkBox {"Married"} $ married !$ p,
            ui_labelled {"Mother: "} $ GTK.pick peopleByName $ mother !$ p,
            ui_labelled {"Father: "} $ GTK.pick peopleByName $ father !$ p,
            GTK.layoutGrow $ ui_people (children p)
        ]
    ]
];

window_person : Person -> Action GTK.Window
= fn p => std_window (name !$ {p}) (ui_person {p});

window_people : Action GTK.Window
= std_window {"People"} (ui_people people);
end;

### Calculator

window_calc : Action GTK.Window
= let
    opentype P;
    pvalue = property @P @Number !"pvalue";
    aval = pvalue !$ {openEntity @P !"a4706230-2c61-44b1-b600-516e7a54c607"};
    bval = pvalue !$ {openEntity @P !"9d284ad2-e141-4114-ae50-8829a6db710f"};
    in std_window {"Calc"} $ GTK.vertical
    [
        #GTK.textEntry aval,
        #GTK.textEntry bval,
        #GTK.label $ aval / bval
    ];

### Switching Value

window_switch : Action GTK.Window
= let
    opentype P;
    pbool = property @P @Boolean !"pbool";
    ptext = property @P @Text !"ptext";
    sw_pick = pbool !$ {openEntity @P !"59eb2d87-f815-47ef-b7dc-8fe434151bb6"};
    sw_val1 = ptext !$ {openEntity @P !"6d9f7afa-1091-49cc-8646-8e613bb75ee5"};
    sw_val2 = ptext !$ {openEntity @P !"934712ae-73a7-4084-8a43-d618c737fd56"};
    in std_window {"Switch"} $ GTK.vertical
    [
        #GTK.textEntry sw_pick),
        GTK.checkBox {"pick"} sw_pick,
        GTK.layoutGrow $ GTK.dynamic {if %sw_pick then GTK.textArea (wholeModelText sw_val1) else GTK.textArea (wholeModelText sw_val2)}
    ];

### Imported Files

window_files : Action GTK.Window
= let
    #Files = @type !f649e7d7-7e98-4c86-919c-34f52ac12c7a;
    #caption = %4a8ca041-a67d-4a1e-b212-9243fca635b0;
    window_file = fn f => std_window {"File"} $ GTK.vertical
    [
        #GTK.textEntry $ caption f
    ];
    in std_window {"Files"} $ GTK.vertical
    [
        #GTK.button "Import" {file_import Files $ fn f => std_window $ window_file f},
        #GTK.layoutGrow $ GTK.listTable [column "Caption" caption, column "Size" file_size] window_file Files
    ];

### Constant Edit

window_constant : Action GTK.Window
= std_window {"Constant"} $ GTK.vertical
[
    GTK.checkBox {"off"} {False},
    GTK.checkBox {"on"} {True},
    GTK.textEntry {"constant"},
    GTK.layoutGrow $ GTK.textArea (wholeModelText $ {"constant"})
];

### CSS
window_css: Action GTK.Window
= do
    cssref <- newMemTextModel;
    cssref := ".y, .y > text {color:green; font-family: \"serif\";}";
    sometext <- newMemWholeModel;
    sometext := "whatever";
    std_window {"CSS"} $ GTK.styleSheet (Debug.GTK.ignoreUpdateUIExceptions cssref) $ GTK.name "root" $ GTK.vertical
        [
            GTK.styleClass "x" $ GTK.name "A" $ GTK.checkBox {"Box"} {True},
            GTK.styleClass "x" $ GTK.name "B" $ GTK.button {"Button"} {return ()},
            GTK.styleClass "x" $ GTK.name "C" $ GTK.textEntry sometext,
            GTK.layoutGrow $ GTK.styleClass "y" $ GTK.name "D" $ GTK.textArea cssref,
            GTK.styleClass "y" $ GTK.name "E" $ GTK.label {"Some Text"}
        ];
    end;

### Drawing
window_drawing: WholeModel +Time -> Action GTK.Window
= fn now => let using Colour; using Cairo in do
    tzref <- newTimeZoneModel now;
    std_window {"Drawing"} $ GTK.draw {fn (w,h) => let
        size = min w h;
        in timeToLocal %tzref %now >- match
            DateAndTime _ (HourMinuteSecond _ _ s) =>
                translate (w / 2, h / 2) $
                scale (size, size) $
                scale (-0.5, -0.5) $
                rotate (s ~* pi ~/ 30) $
                operatorOver $
                source purple $
                lineCapSquare $
                lineWidth 0.01 $
                stroke $ concatPath [moveTo (0, 0), lineTo (0, 1)];
            end};
    end;

window_list: Action GTK.Window
= do
    peopleList <- getFiniteSetModelList (orderOn name alphabetical) people;
    std_window {"List"} $ GTK.list ui_person peopleList;
    end;

### Text Selection
window_textselection: Action GTK.Window
= do
    tref1 <- newMemTextModel;
    tref1 := "111";
    tref2 <- newMemTextModel;
    tref2 := "222";
    tref3 <- newMemTextModel;
    tref3 := "333";
    sel <- newMemWholeModel;
    let
        notify: Action TextModel -> Action Unit
        = fn atref => sel := atref;
    in std_window {"Text Selection"} $ GTK.styleSheet {"* {padding: 2pt;}"} $ GTK.vertical
    [
        GTK.notifySelection notify $ GTK.textArea tref1,
        GTK.notifySelection notify $ GTK.textArea tref2,
        GTK.notifySelection notify $ GTK.textArea tref3,
        GTK.dynamic {GTK.exec $ mapAction (fn tref => GTK.textArea (wholeModelText tref)) %sel}
    ];
    end;

### Cairo Image
window_cairoimage: Action GTK.Window
= let
    using Colour;
    using Cairo;
    using GTK;
    dimensions: Integer *: Integer
    = (400,400);
    drawing: Integer *: Integer -> Drawing Handler
    = fn (w,h) => let
        size = min w h;
        square: Drawing Handler
        = fill $ concatPath [moveTo (0, 0), lineTo (0, 1), lineTo (1, 1), lineTo (1, 0), lineTo (0, 0)];
        squares: List ((Integer *: Integer) *: Colour)
        =
        [
            ((0,0), black),
            ((1,0), red),
            ((2,0), green),
            ((3,0), yellow),
            ((0,1), blue),
            ((1,1), magenta),
            ((2,1), cyan),
            ((3,1), white),
            ((0,2), purple),
            ((1,2), brown),
            ((2,2), pink),
            ((3,2), cornflowerblue),
            ((0,3), lavender),
            ((1,3), ivory),
            ((2,3), midnightblue)
        ];
        block: Number -> Drawing Handler
        = fn a => concatDrawing
        [
            concatDrawing $ mapList (fn (s,c) => translate s $ source (MkAlphaColourFraction a c) $ square) squares,
            lineWidth 0.05 $ source black $ stroke $ arc (2,2) 2 0 (2 ~* pi)
        ];
        in
            scale (size, size) $
            scale (0.125, 0.125) $
            operatorOver $ concatDrawing
            [
                translate (0,0) $ block 1,
                translate (0,4) $ block (2/3),
                translate (4,0) $ block (1/3),
                translate (4,4) $ block 0
            ];
    in std_window {"Cairo Image"} $ vertical
    [
        layoutGrow $ draw {drawing},
        layoutGrow $ styleSheet {"* {border: solid 5px black;padding: 5px;}"} $ image {drawToImage dimensions $ drawing dimensions}
    ];

### Start Window

rec
window_start : Action GTK.Window
= do
    now <- newClock $ Seconds 1;
    timeZone <- newTimeZoneModel now;
    let
        utcDate = {%now};
        localNow = {timeToLocal %timeZone %now};
        today = {%localNow >- match DateAndTime day _ => day end};
        in do
        std_window {"Pinafore"} $ GTK.vertical
        [
            GTK.label {"UTC time: " <> show %now},
            GTK.label {"UTC date: " <> show %utcDate},
            GTK.label {"Local time: " <> show %localNow},
            GTK.label {"Local date: " <> show %today},
            GTK.label {"Time zone offset minutes: " <> show %timeZone},
            GTK.button {"Calculated Form"} {window_calc},
            GTK.button {"Switch"} {window_switch},
            GTK.button {"Files"} {window_files},
            GTK.button {"Constant"} {window_constant},
            GTK.button {"CSS"} {window_css},
            GTK.button {"Drawing"} {window_drawing now},
            GTK.button {"List"} {window_list},
            GTK.button {"Text Selection"} {window_textselection},
            GTK.button {"Disabled"} unknown,
            GTK.button {"Unowned self"} {window_start},
            GTK.owned $ GTK.button {"Owned Self"} {window_start},
            GTK.button {"Cairo Image"} {window_cairoimage},
            GTK.layoutGrow $ GTK.blank
        ];
        end;
    end;
end;

in window_start
