#!/usr/bin/pinafore
let
    import "pinafore-gnome";
    import "UILib";
    using UILib.;
in run.Context $ fn context =>
let

    MkContext.Named = mkContext.Named context;

    ### EventTime

    # An event can either be at a particular time, or a whole-day event.
    datatype storable EventTime of
        EventTimeDate Date !"Date"; # all-day event
        EventTimeTime LocalTime !"Time"; # event at a time
    end;

    showEventTime: EventTime -> Text
    = match
        EventTimeDate d => encode (unixAsText.Date "%F") d;
        EventTimeTime t => encode (unixAsText.LocalTime "%F %R") t;
        end;

    eventTimeDate: EventTime -> Date
    = match
        EventTimeDate d => d;
        EventTimeTime (DateAndTime d _) => d
        end;

    setEventTimeDate: Date -> Maybe EventTime -> Maybe EventTime
    = fn d, et => Just $ et >- match
        Just (EventTimeTime (DateAndTime _ t)) => EventTimeTime (DateAndTime d t);
        _ => EventTimeDate d;
        end;

    eventModelTimeDate: WholeModel EventTime -> WholeModel Date
    = fn r => lensMap.WholeModel eventTimeDate setEventTimeDate r;

    eventModelTimeTimeOfDay: WholeModel EventTime -> WholeModel TimeOfDay
    = fn r => let
        eventTimeTimeOfDay: Maybe EventTime -> Maybe TimeOfDay
        = match
            Just (EventTimeTime (DateAndTime _ tod)) => Just tod;
            _ => Nothing;
            end;

    setEventTimeTimeOfDay: Maybe TimeOfDay -> Maybe EventTime -> Maybe (Maybe EventTime)
    = fn mtod, met => Just $ met >- match
        Nothing => Nothing;
        Just et => Just $ mtod >- match
            Nothing => EventTimeDate $ eventTimeDate et;
            Just tod => EventTimeTime $ DateAndTime (eventTimeDate et) tod;
            end;
        end;
    in maybeLensMap.WholeModel eventTimeTimeOfDay setEventTimeTimeOfDay r;

    # for ordering
    eventTimeTime: EventTime -> LocalTime
    = match
        EventTimeDate d => DateAndTime d midnight;
        EventTimeTime t => t
        end;

    eventTimeOrder: ModelOrder EventTime
    = map.ModelOrder eventTimeTime localChronological;


    ### Event

    opentype Event;
    subtype Event <: Named;
    events: FiniteSetModel Event
    = property @Event @Unit !"type.event" store !@ {()};

    eventTime = property @Event @EventTime !"event.time" store;
    eventNotes = property @Event @Text !"item.description" store;

    eventOrder: ModelOrder Event
    = on.ModelOrder eventTime eventTimeOrder;

    eventData: FiniteSetModel (EventTime *: Text)
    = (eventTime **.Property name) !$$ events;

    eventDataOrder: ModelOrder (EventTime *: Text)
    = map.ModelOrder fst eventTimeOrder;

    eventList: WholeModel +Date -> WholeModel +(List (EventTime *: Text))
    = fn todaymodel => {
        let
            today: Date = %todaymodel;

            pickCurrent: EventTime *: Text -> Boolean
            = fn (t,_) => ge $ calendrical (eventTimeDate t) today;
        in (EventTimeDate today,"Today") :: filter pickCurrent %(toList.FiniteSetModel eventDataOrder eventData)
        };


    ### GTK

    # Text for the overview tab.
    overviewModel: WholeModel +Date -> WholeModel +Text
    = fn todaymodel => {concat.Text $ map.List (fn (t,n) => showEventTime t <>.Text ": " <>.Text n <>.Text "\n") %(eventList todaymodel)};

    # Overview tab GTK
    overviewPane: Pane
    = simple.Pane "Overview" $ exec.GTK $ do
        now <- newClock $ Seconds 60; # update every minute
        tz <- newTimeZoneModel.LocalTime now;
        pure $ label.GTK $ overviewModel {fromTime.LocalTime %tz %now >- match DateAndTime d _ => d end};
        end;

    calendarWindow: WholeModel +Event -> Action Window.GTK
    = fn evt => fix $ fn window =>
        open.Window.GTK gtk (200,200) {"date of " <>.Text %(name !$% evt)} $ vertical.GTK
        [
            calendar.GTK $ eventModelTimeDate $ eventTime !$% evt,
            button.GTK {"Done: " <>.Text show %(eventModelTimeDate $ eventTime !$% evt)} {close.Window.GTK window}
        ];

    eventUI: WholeModel +Event -> Element.GTK
    = fn evt => vertical.GTK
    [
        textEntry.GTK $ name !$% evt,
        horizontal.GTK
        [
            button.GTK {"cal"} {calendarWindow evt},
            textEntry.GTK $ reverse.Prism asText.Date !$ (eventModelTimeDate $ eventTime !$% evt),
            textEntry.GTK $ reverse.Prism (unixAsText.TimeOfDay "%H:%M") !$ (eventModelTimeTimeOfDay $ eventTime !$% evt)
        ],
        layoutGrow.GTK $ textArea.GTK (fromWhole.TextModel $ eventNotes !$% evt)
    ];

    eventWindow: Event -> Action Window.GTK
    = fn evt => paneWindow $ namedPane eventUI {evt};

    newEvent: Action Event
    = do
        item <- newOpenEntity @Event;
        day <- getNowLocal.Date;
        eventTime !$ {item} := EventTimeDate day;
        name !$ {item} := "";
        pure item;
        end;

    eventsTableUI: WholeModel Event -> Element.GTK
    = fn selection => let
        columns: List (WholeModel +Text *: (Event -> WholeModel Text))
        = let
            timeColumn: WholeModel +Text *: (Event -> WholeModel Text)
            = ({"When"},fn e => {showEventTime $ %(eventTime !$ {e})});
            nameColumn: WholeModel +Text *: (Event -> WholeModel Text)
            = ({"What"},fn e => name !$ {e});
            in [timeColumn,nameColumn];
        in exec.GTK $ do
            lm <- getList.FiniteSetModel eventOrder events;
            pure $ listTable.GTK columns lm eventWindow (Just selection);
            end;

    eventsPresentation: TypePresentation Event
    = let
        title = "Events";
        itemSet = events;
        newItems =
        [
            let name = "New Event"; mkey = Just "Ctrl+K"; newItem = newEvent in MkNewItem
        ];
        itemOpenAction = fn evt => eventWindow evt >> pure ();
        itemElement = eventUI;
        listElement = eventsTableUI;
        in MkTypePresentation;

in do
    eventsPane <- presentList.Pane eventsPresentation;
    p <- notebook.Pane {"Events"} [overviewPane,eventsPane];
    paneWindow p
    end
