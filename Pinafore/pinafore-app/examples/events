#!/usr/bin/pinafore
let
import "pinafore-gnome";
import "uistuff/selection";
import "uistuff/named";
in runUIStuff $ fn uistuff@MkUIStuff =>
mkNamed uistuff >- fn MkNamedStuff =>
let
using Storage;

### EventTime

# An event can either be at a particular time, or a whole-day event.
datatype storable EventTime of
    EventTimeDate Date !"Date"; # all-day event
    EventTimeTime LocalTime !"Time"; # event at a time
end;

showEventTime: EventTime -> Text
= match
    EventTimeDate d => unixFormatDate "%F" d;
    EventTimeTime t => unixFormatLocalTime "%F %R" t;
    end;

eventTimeDate: EventTime -> Date
= match
    EventTimeDate d => d;
    EventTimeTime (DateAndTime d _) => d
    end;

setEventTimeDate: Date -> Maybe EventTime -> Maybe EventTime
= fns d et => Just $ et >- match
    Just (EventTimeTime (DateAndTime _ t)) => EventTimeTime (DateAndTime d t);
    _ => EventTimeDate d;
    end;

eventModelTimeDate: WholeModel EventTime -> WholeModel Date
= fn r => lensMapWholeModel eventTimeDate setEventTimeDate r;

eventModelTimeTimeOfDay: WholeModel EventTime -> WholeModel TimeOfDay
= fn r => let
    eventTimeTimeOfDay: Maybe EventTime -> Maybe TimeOfDay
    = match
        Just (EventTimeTime (DateAndTime _ tod)) => Just tod;
        _ => Nothing;
        end;

setEventTimeTimeOfDay: Maybe TimeOfDay -> Maybe EventTime -> Maybe (Maybe EventTime)
= fns mtod met => Just $ met >- match
    Nothing => Nothing;
    Just et => Just $ mtod >- match
        Nothing => EventTimeDate $ eventTimeDate et;
        Just tod => EventTimeTime $ DateAndTime (eventTimeDate et) tod;
        end;
    end;
in maybeLensMapWholeModel eventTimeTimeOfDay setEventTimeTimeOfDay r;

# for ordering
eventTimeTime: EventTime -> LocalTime
= match
    EventTimeDate d => DateAndTime d midnight;
    EventTimeTime t => t
    end;

eventTimeOrder: ModelOrder EventTime
= mapOrder eventTimeTime localChronological;


### Event

opentype Event;
subtype Event <: Named;
events: FiniteSetModel Event
= property @Event @Unit !"type.event" store !@ {()};

eventTime = property @Event @EventTime !"event.time" store;
eventNotes = property @Event @Text !"item.description" store;

eventOrder: ModelOrder Event
= orderOn eventTime eventTimeOrder;

eventData: FiniteSetModel (EventTime *: Text)
= (eventTime !** name) !$$ events;

eventDataOrder: ModelOrder (EventTime *: Text)
= mapOrder fst eventTimeOrder;

eventList: WholeModel +Date -> WholeModel +(List (EventTime *: Text))
= fn todaymodel => {
    let
        today: Date = %todaymodel;

        pickCurrent: EventTime *: Text -> Boolean
        = fn (t,_) => ge $ calendrical (eventTimeDate t) today;
    in (EventTimeDate today,"Today") :: filter pickCurrent %(finiteSetModelList eventDataOrder eventData)
    };


### GTK

# Text for the overview tab.
overviewModel: WholeModel +Date -> WholeModel +Text
= fn todaymodel => {textConcat $ mapList (fn (t,n) => showEventTime t <> ": " <> n <> "\n") %(eventList todaymodel)};

# Overview tab GTK
overviewPane: Pane
= pane "Overview" $ exec.GTK $ do
    now <- newClock $ Seconds 60; # update every minute
    tz <- newTimeZoneModel now;
    return $ label.GTK $ overviewModel {timeToLocal %tz %now >- match DateAndTime d _ => d end};
    end;

calendarWindow: WholeModel +Event -> Action Window.GTK
= fn evt => fixAction $ fn window =>
    openWindow.GTK gtk (200,200) {"date of " <> %(name !$% evt)} $ vertical.GTK
    [
        calendar.GTK $ eventModelTimeDate $ eventTime !$% evt,
        button.GTK {"Done: " <> show %(eventModelTimeDate $ eventTime !$% evt)} {closeWindow.GTK window}
    ];

eventUI: WholeModel +Event -> Element.GTK
= fn evt => vertical.GTK
[
    textEntry.GTK $ name !$% evt,
    horizontal.GTK
    [
        button.GTK {"cal"} {calendarWindow evt},
        textEntry.GTK $ interpretDateAsText $ eventModelTimeDate $ eventTime !$% evt,
        textEntry.GTK $ unixInterpretTimeOfDayAsText "%H:%M" $ eventModelTimeTimeOfDay $ eventTime !$% evt
    ],
    layoutGrow.GTK $ textArea.GTK (wholeModelText $ eventNotes !$% evt)
];

eventWindow: Event -> Action Window.GTK
= fn evt => paneWindow $ namedPane eventUI {evt};

newEvent: Action Event
= do
    item <- newOpenEntity @Event;
    day <- getDate;
    eventTime !$ {item} := EventTimeDate day;
    name !$ {item} := "";
    return item;
    end;

eventsTableUI: WholeModel Event -> Element.GTK
= fn selection => let
    columns: List (WholeModel +Text *: (Event -> WholeModel Text))
    = let
        timeColumn: WholeModel +Text *: (Event -> WholeModel Text)
        = ({"When"},fn e => {showEventTime $ %(eventTime !$ {e})});
        nameColumn: WholeModel +Text *: (Event -> WholeModel Text)
        = ({"What"},fn e => name !$ {e});
        in [timeColumn,nameColumn];
    in exec.GTK $ do
        lm <- getFiniteSetModelList eventOrder events;
        return $ listTable.GTK columns lm eventWindow (Just selection);
        end;

in do
    eventsPane <- selectionPairPane "Events" events [newItemMenuAction ("New Event") (Just "Ctrl+K") newEvent events] eventWindow eventsTableUI eventUI;
    p <- notebookPane {"Events"} [overviewPane,eventsPane];
    paneWindow p
    end
