#!/usr/bin/pinafore
import "pinafore-gnome", "UILib" in
with UILib. in
run.Context $ fn context =>
let

    Mk.Context.Named = mkContext.Named context;

    # something with a lifespan
    opentype Lifespanned;
    # birth and death dates
    birthdate = property @Lifespanned @Date !"lifespan.start.date" store;
    deathdate = property @Lifespanned @Date !"lifespan.end.date" store;

    # physical locations, that have addresses
    opentype Location;
    address = property @Location @Text !"location.address.withincity" store;
    locphone = property @Location @Text !"location.telephone" store;
    city = property @Location @Text !"location.address.city" store;
    postcode = property @Location @Text !"location.address.postcode" store;
    province = property @Location @Text !"location.address.province" store;
    country = property @Location @Text !"location.address.country" store;

    locationUI: WholeModel +Location -> Element.GTK
    = fn loc => vertical.GTK
    [
        layoutGrow.GTK $ labelled.GTK {"Address: "} $ textArea.GTK (fromWhole.TextModel $ address !$% loc),
        labelled.GTK {"City: "} $ textEntry.GTK $ city !$% loc,
        labelled.GTK {"Postcode/ZIP: "} $ textEntry.GTK $ postcode !$% loc,
        labelled.GTK {"State/Province: "} $ textEntry.GTK $ province !$% loc,
        labelled.GTK {"Country: "} $ textEntry.GTK $ country !$% loc,
        labelled.GTK {"Phone: "} $ textEntry.GTK $ locphone !$% loc
    ];

    let rec
        # a person or organisation
        dynamictype LegalEntity = Person | Organisation;
        subtype LegalEntity <: Named;
        subtype LegalEntity <: Lifespanned;
        email = property @LegalEntity @Text !"contact.email" store;
        phone = property @LegalEntity @Text !"contact.telephone" store;
        home = property @LegalEntity @Location !"being.location" store;
        legalentities: FiniteSetModel LegalEntity
        = property @LegalEntity @Unit !"type.legalentity" store !@ {()};

        # a person
        dynamictype Person = !"type.person";
        people: FiniteSetModel Person
        = maybeMap.FiniteSetModel (check @Person) legalentities;
        # family relationships between people
        mother = property @Person @Person !"relation.family.mother" store;
        father = property @Person @Person !"relation.family.father" store;
        children: WholeModel +Person -> FiniteSetModel Person
        = fn p => (mother !@% p) <:|:> (father !@% p);
        married = property @Person @Boolean !"relation.family.spouse.exist" store;

        # employment relationship
        employer = property @Person @LegalEntity !"relation.employer" store;
        employees: WholeModel +LegalEntity -> FiniteSetModel Person
        = fn p => employer !@% p;

        # an organisation
        dynamictype Organisation = !"type.organisation";
        organisations: FiniteSetModel Organisation
        = property @Organisation @Unit !"type.organisation" store !@ {()};
    end;

    ### User Interface

    let rec
        contactPages: WholeModel +LegalEntity -> List (Element.GTK *: Element.GTK)
        = fn er =>
        [
            page.GTK {"Social"} $ vertical.GTK
            [
                labelled.GTK {"Email: "} $ textEntry.GTK $ email !$% er,
                labelled.GTK {"Phone: "} $ textEntry.GTK $ phone !$% er
            ],
            page.GTK {"Home"} $ locationUI $ home !$% er
        ];

        personPages: WholeModel +Person -> List (Element.GTK *: Element.GTK)
        = fn p =>
        [
            page.GTK {"Work"} $ vertical.GTK
            [
                labelled.GTK {"Employer: "} $ pick.GTK (byName legalentities) $ employer !$% p
            ],
            page.GTK {"Family"} $ familyUI p
        ];

        familyUI: WholeModel +Person -> Element.GTK
        = fn p => vertical.GTK
        [
            labelled.GTK {"Birth: "} $ textEntry.GTK $ reverse.Prism asText.Date !$ birthdate !$% p,
            labelled.GTK {"Death: "} $ textEntry.GTK $ reverse.Prism asText.Date !$ deathdate !$% p,
            checkBox.GTK {"Married"} $ married !$% p,
            labelled.GTK {"Mother: "} $ pick.GTK (byName people) $ mother !$% p,
            labelled.GTK {"Father: "} $ pick.GTK (byName people) $ father !$% p,
            label.GTK {"Children:"},
            layoutGrow.GTK $ namedItemTable (children p) contactModelUI Nothing
        ];

        organisationPages: WholeModel +Organisation -> List (Element.GTK *: Element.GTK)
        = fn subj =>
        [
            page.GTK {"Employees"} $ namedItemTable (employees subj) contactModelUI Nothing
        ];

        contactUI: LegalEntity -> Element.GTK
        = fn e => let
            pages: List (Element.GTK *: Element.GTK)
            = contactPages {e} <>.List (e >- match
                p:? Person => personPages {p};
                o:? Organisation => organisationPages {o};
                end);
            in vertical.GTK
            [
                labelled.GTK {"Name: "} $ textEntry.GTK $ name !$% {e},
                layoutGrow.GTK $ notebook.GTK unknown pages
            ];

        contactModelUI: WholeModel +LegalEntity -> Element.GTK
        = fn model => dynamic.GTK $ coMap.WholeModel contactUI model;
    end;

    contactsPresentation: TypePresentation LegalEntity
    = let
        title = "Contacts";
        itemSet = legalentities;
        newItems =
        [
            let name = "New Person"; mkey = Just "Ctrl+K"; newItem = new.DynamicEntity @Person in Mk.NewItem,
            let name = "New Organisation"; newItem = new.DynamicEntity @Organisation in Mk.NewItem
        ];
        itemElement = contactModelUI;
        in namedToTypePresentation Mk.NamedTypePresentation;

    contactsWindow: Action Window.GTK
    = do
        p <- presentList.Pane contactsPresentation;
        paneWindow p;
        end;

in contactsWindow
