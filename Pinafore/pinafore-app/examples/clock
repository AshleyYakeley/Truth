#!/usr/bin/pinafore
let
import Colour;
import Cairo;
import GTK;

scaleDrawing: Drawing a -> Integer *: Integer -> Drawing a
= fns d (w,h) => let
    size = min w h;
    in translate (w/2,h/2) $ scale (size/2,size/2) d;

circle: Number *: Number -> Number -> Path
= fns centre radius => arc centre radius 0 (2 ~* pi);

tickMark: Integer -> Drawing None
= fn m => let
    major = mod m 5 == 0
    in lineWidth (if major then 0.015 else 0.005) $ stroke $ concatPath [moveTo (0,if major then 0.8 else 0.85), lineTo (0,0.95)];

face: Drawing None
= concatDrawing
[
    source antiquewhite $ fill $ circle (0,0) 1,
    source black $ lineWidth 0.01 $ stroke $ circle (0,0) 1,
    concatDrawing $ mapList (fn m => rotate (m ~* pi ~/ 30) $ tickMark m) $ range 0 59
];

hourHand: Drawing None
= source navy $ lineWidth 0.1 $ stroke $ concatPath [moveTo (0,0), lineTo (0,-0.5)];

minuteHand: Drawing None
= source navy $ lineWidth 0.05 $ stroke $ concatPath [moveTo (0,0), lineTo (0,-0.8)];

secondHand: Drawing None
= source red $ lineWidth 0.01 $ stroke $ concatPath [moveTo (0,0), lineTo (0,-0.9)];

in do
    now <- newClock $ Seconds 0.1;
    tz <- getCurrentTimeZone;
    GTK.run $ fn gtk => openWindow gtk (300,400) {"Clock"} $ draw
    {
        scaleDrawing $
            timeToLocal tz %now >- match
                DateAndTime _ (SinceMidnight (Seconds ss)) => let
                    s = floor $ modR ss 60; # floor for ticking motion
                    m = modR (ss / 60) 60;
                    h = modR (ss / 3600) 24;
                    in concatDrawing
                    [
                        face,
                        rotate (h ~* pi ~/ 6) hourHand,
                        rotate (m ~* pi ~/ 30) minuteHand,
                        rotate (s ~* pi ~/ 30) secondHand
                    ]
            end
    }
    end
