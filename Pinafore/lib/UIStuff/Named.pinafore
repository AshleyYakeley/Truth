let
import GTK;
import UIStuff.Selection;

#| An open entity type; something with a name
opentype Named;

#| A name is a text that identifies (in some sense) an entity.
name: Named ~> Text;
name = property @Named @Text !"identify.name";

#| Order alphabetically (case-insensitive) by name
nameOrder: RefOrder Named;
nameOrder = orderOn name alphabetical;

#| Order a set of entities by their names.
byName: FiniteSetRef {+a,+Named} -> WholeRef +(List (a *: Text));
byName ref = setList (mapOrder fst nameOrder) $ (identity !** name) !$$ ref;

namedPane: (WholeRef +a -> Element) -> WholeRef +(a & Named) -> Pane;
namedPane iui e = MkPane (name !$% e) (iui $ immutWhole e) {[]};

nameColumn: WholeRef +Text *: (Named -> WholeRef Text);
nameColumn = ({"Name"},fn p => name !$ {p});

namedTable: FiniteSetRef {a,+Named} -> (a -> Action Any) -> Maybe (WholeRef {a,+Named}) -> Element;
namedTable sref onActivate msel = exec $ do
    lref <- getSetList nameOrder sref;
    return $ listTable [nameColumn] lref onActivate msel;
    end;

namedItemTable: FiniteSetRef {a,+Named} -> (WholeRef +a -> Element) -> Maybe (WholeRef {a,+Named}) -> Element;
namedItemTable set iui msel = withContext $ fn gtk => namedTable set (fn e => paneWindow gtk $ namedPane iui {e}) msel;

namedPairPane: Context -> Text -> FiniteSetRef {a,+Named} -> List (SetRef a -> ((a & Named) -> Action Unit) -> MenuItem) -> (WholeRef +a -> Element) -> Action Pane;
namedPairPane gtk name set mitems getSelectedUI = let
    getSelectorUI sel = namedItemTable set getSelectedUI (Just sel);
    iopen e = paneWindow gtk $ namedPane getSelectedUI {e};
    in selectionPairPane name set (mapList (fn mitem => mitem set) mitems) iopen getSelectorUI getSelectedUI;

in expose
    Named,
    name,
    byName,
    namedPane,
    namedTable,
    namedItemTable,
    namedPairPane
