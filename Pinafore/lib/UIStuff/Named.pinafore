let
import GTK;
import UIStuff.Selection;

#| An open entity type; something with a name
opentype Named;

#| A name is a text that identifies (in some sense) an entity.
name: Named ~> Text
= property @Named @Text !"identify.name";

#| Order alphabetically (case-insensitive) by name
nameOrder: ModelOrder Named
= orderOn name alphabetical;

#| Order a set of entities by their names.
byName: FiniteSetModel {+a,+Named} -> WholeModel +(List (a *: Text))
= fn model => finiteSetModelList (mapOrder fst nameOrder) $ (identity !** name) !$$ model;

namedPane: (WholeModel +a -> Element) -> WholeModel +(a & Named) -> Pane
= fns iui e => MkPane (name !$% e) (iui $ immutWholeModel e) {[]};

nameColumn: WholeModel +Text *: (Named -> WholeModel Text)
= ({"Name"},fn p => name !$ {p});

namedTable: FiniteSetModel {a,+Named} -> (a -> Action Any) -> Maybe (WholeModel {a,+Named}) -> Element
= fns sm onActivate msel => exec $ do
    lm <- getFiniteSetModelList nameOrder sm;
    return $ listTable [nameColumn] lm onActivate msel;
    end;

namedItemTable: FiniteSetModel {a,+Named} -> (WholeModel +a -> Element) -> Maybe (WholeModel {a,+Named}) -> Element
= fns set iui msel => withContext $ fn gtk => namedTable set (fn e => paneWindow gtk $ namedPane iui {e}) msel;

namedPairPane: Context -> Text -> FiniteSetModel {a,+Named} -> List (SetModel a -> ((a & Named) -> Action Unit) -> MenuItem) -> (WholeModel +a -> Element) -> Action Pane
= fns gtk name set mitems getSelectedUI => let
    getSelectorUI = fn sel => namedItemTable set getSelectedUI (Just sel);
    iopen = fn e => paneWindow gtk $ namedPane getSelectedUI {e};
    in selectionPairPane name set (mapList (fn mitem => mitem set) mitems) iopen getSelectorUI getSelectedUI;

in expose
    Named,
    name,
    byName,
    namedPane,
    namedTable,
    namedItemTable,
    namedPairPane
