expose namespace UILib of

    import "pinafore-gnome";
    using GTK;

    import "UILib/Pane";

    namespace UILib of

        #| An open entity type; something with a name
        opentype Named;

        datatype NamedTypePresentation {-p,+q} of
            MkNamedTypePresentation of
                #| pane title
                title: Text;

                #| the set of items
                itemSet: FiniteSetModel {-p,+q};

                #| menu items for creating new items
                newItems: List (NewItem q) = [];

                itemElement: WholeModel +p -> Element;
            end;
        end;

        namespace Named of

            datatype Props of
                MkProps of
                    #| A name is a text that identifies (in some sense) an entity.
                    name: Property Named Text;
                    #| Order alphabetically (case-insensitive) by name
                    nameOrder: ModelOrder Named;
                    #| Order a set of entities by their names.
                    byName: FiniteSetModel {+a,+Named} -> WholeModel +(List (a *: Text));
                end;
            end;

            mkProps: Store -> Props
            = fn store => let
                name = property @Named @Text !"identify.name" store;
                nameOrder = on.ModelOrder name alphabetical.Order;
                byName = fn model => toList.FiniteSetModel (map.ModelOrder fst.Product nameOrder) $ (id.Property **.Property name) !$$ model;
                in MkProps;

            datatype Context <: Context.Pane & Props of
                MkContext of
                    MkContext.Pane;
                    MkProps;
                    namedPane: (WholeModel +a -> Element) -> WholeModel +(a & Named) -> Pane;
                    nameColumn: WholeModel +Text *: (Named -> WholeModel Text);
                    namedTable: FiniteSetModel {a,+Named} -> (a -> Action Any) -> Maybe (WholeModel {a,+Named}) -> Element;
                    namedItemTable: FiniteSetModel {a,+Named} -> (WholeModel +a -> Element) -> Maybe (WholeModel {a,+Named}) -> Element;
                    namedToTypePresentation: NamedTypePresentation {item,+Named} -> TypePresentation {item,-Named};
                end;
            end;

            mkContext: Context.UILib -> Context.Named
            = fn MkContext.UILib => let
                MkContext.Pane = mkContext.Pane MkContext.UILib;

                MkProps = mkProps store;

                namedPane = fn iui, e => let
                    titleModel= name !$% e;
                    extraMenusModel = {[]};
                    element = iui $ immut.WholeModel e;
                    in MkPane;

                nameColumn = ({"Name"},fn p => name !$ {p});

                namedTable = fn sm, onActivate, msel => exec $ do
                    lm <- getList.FiniteSetModel nameOrder sm;
                    pure.Action $ listTable [nameColumn] lm onActivate msel;
                    end;

                namedItemTable = fn set, iui, msel =>
                    namedTable set (fn e => paneWindow $ namedPane iui {e}) msel;

                namedToTypePresentation: NamedTypePresentation {item,+Named} -> TypePresentation {item,-Named}
                = fn MkNamedTypePresentation => let
                    itemOpenAction = fn e => (paneWindow $ namedPane itemElement {e}) >> pure ();
                    listElement = fn sel => namedItemTable itemSet itemElement (Just sel);
                    in MkTypePresentation;

            in MkContext.Named;

        end

    end

end
